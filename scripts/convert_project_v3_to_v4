#!/bin/sh

usage() {
	echo "Usage: $0 <project-v3> <project-v4>"
	echo
	echo "SMPARSER must point to the smparser tool."
	echo "Sub-projects are not converted."
	echo
	exit 1
}

error() {
	echo "error: $*"
}

info() {
	echo "$*"
}

debug() {
	[ "$DEBUG" = 1 ] && echo "debug: $*"
}

die() {
	error "$*"
	exit 1
}

if [ ! -x "$SMPARSER" ]; then
	die "SMPARSER does not point to an executable."
fi
SMPARSER=$(realpath "$SMPARSER")

src_v3="$1"
dst_v4="$2"

if [ "$src_v3" = "" -o "$dst_v4" = "" ]; then
	usage
fi

if [ ! -d "$src_v3/.smip" ]; then
	die "source directory '$src_v3' is not a smit project version 3."
fi

if [ -e "$dst_v4" ]; then
	die "destination directory '$dst_v4' must not exist."
fi

cat_file_v3() {
	project_dir="$1"
	object_id=$2
	prefix=$(echo $object_id | sed -e "s/\(..\).*/\\1"/)
	suffix=$(echo $object_id | sed -e "s/^..//")
	cat "$project_dir/.smip/objects/$prefix/$suffix"
}

get_v3_history() {
	local src_v3="$1"
	parent="$2"
	if [ "$parent" = "" ]; then return; fi

	history=""
	while [ "$parent" != null -a "$parent" != "" ]; do
		history="$parent $history"
		parent=$(cat_file_v3 "$src_v3" $parent | grep ^+parent | head -1 | sed -e "s/^+parent *//")
	done
	echo $history
}

convert_v3_to_v4_master_file() {
	src_v3="$1"
	dst_v4="$2"
	filename="$3"
	new_location="$4" # within $dst_v4

	# recall the history...
	id=$(cat "$src_v3/.smip/refs/$filename")
	history=$(get_v3_history "$src_v3" "$id")

	# replay and commit
	for i in $history; do
		author=$(cat_file_v3 "$src_v3" $i | grep +author | sed -e "s/.* //")
		ctime=$(cat_file_v3 "$src_v3" $i | grep +ctime | sed -e "s/.* //")
		cat_file_v3 "$src_v3" $i |
			grep -v ^+ > "$dst_v4/$new_location"
		git -C "$dst_v4" add $new_location
		git -C "$dst_v4" commit -m "convert_v3_to_v4_master" --author "$author <>" --date=$ctime -q
	done
}

# $1 : source v3 smit project
# $2 : destination v4 smit project
#      (must be a checked-out git repo, branch master)
convert_v3_to_v4_master() {
	# create files in branch 'master'
	local src_v3="$1"
	local dst_v4="$2"

	# Create the directory here
	# This is a protection against the following rm -rf
	mkdir "$dst_v4" || exit 1
	git init "$dst_v4"

	# First, copy all
	ls -a "$src_v3" |
	while read f; do
		[ "$f" = "." ] && continue
		[ "$f" = ".." ] && continue
		cp -a "$src_v3/$f" "$dst_v4/."
	done

	# Remove the top level .smip directory
	rm -rf "$dst_v4/.smip"

	# Then remove copied sub projects (detected by their .smip dir)
	find "$dst_v4" -name ".smip" |
	while read f; do
		dname=$(dirname "$f")
		rm -rf "$dname"
	done

	# Add all remaining files
	git -C "$dst_v4" add .

	# Now recreate the .smip dir (v4 format)
	conf_v4=.smip
	mkdir "$dst_v4/$conf_v4"

	# Project configuration
	convert_v3_to_v4_master_file "$src_v3" "$dst_v4" project "$conf_v4/config"

	# views
	if [ -f "$src_v3/.smip/refs/views" ]; then
		id=$(cat "$src_v3/.smip/refs/views")
		cat_file_v3 "$src_v3" $id > "$dst_v4/$conf_v4/views"
		git -C "$dst_v4" add $conf_v4/views
	fi

	# templates
	if [ -d "$src_v3/.smip/templates" ]; then
		cp -a "$src_v3/.smip/templates" "$dst_v4/.templates"
		git -C "$dst_v4" add .templates
	fi

	# trigger
	if [ -f "$src_v3/.smip/refs/trigger" ]; then
		cp "$src_v3/.smip/refs/trigger" "$dst_v4/$conf_v4/trigger"
		git -C "$dst_v4" add "$conf_v4/trigger"
	fi

	author=convert_v3_to_v4_master
	git -C "$dst_v4" commit -m "convert_v3_to_v4_master" --author "$author <>" -q
}

# $1 : src smit-v3 repository
# $2 : dest smit-v4 repo (must be a bare repo)
# $3 : id of first commit of the issue (empty for a new issue)
# $4 : the original entry of the v3 repo
# $5 : the file for mapping v3 and v4 entries identifiers
# stdin: commit message
# stdout : id of first commit
create_commit_issues() {

	debug create_commit_issues $*

	local src_v3="$1"
	local dst_v4="$2"
	local first_commit_id=$3
	local entry=$4
	local mapping_entries_v3_v4="$5"
	# stdin: commit message

	git -C "$dst_v4" read-tree --empty

	shift 3

	# attached files
	# use smparser in order to manage spaces in file names
	# manage at most 10 attached files in a single entry
	files=""
	for i in $(seq 1 10); do
		f=$(cat_file_v3 "$src_v3" "$entry" | "$SMPARSER" - +file $i)
		if [ "$f" = "" ]; then
			# no more file
			break
		fi

		hash=$(echo $f | sed -e "s;/.*;;")
		base_name=$(echo $f | sed -e "s;.*/;;")
		id=$(cat_file_v3 "$src_v3" $hash | git -C "$dst_v4" hash-object -w --stdin)
		git -C "$dst_v4" update-index --add --cacheinfo 100644 $id "$base_name"
	done

	tree_id=$(git -C "$dst_v4" write-tree)

	if [ -z "$first_commit_id" ]; then
		# this is the first commit in the orphan branch
		# read message from stdin
		commit_id=$(git -C "$dst_v4" commit-tree $tree_id)
		first_commit_id=$commit_id
		# branch named after the commit
		branch=issues/$first_commit_id
	else
		branch=issues/$first_commit_id
		parent_id=$(git -C "$dst_v4" show-ref --heads -s "$branch" 2>/dev/null)
		debug parent_id=$parent_id
		# read message from stdin
		commit_id=$(git -C "$dst_v4" commit-tree $tree_id -p $parent_id)
	fi

	# update the branch
	git -C "$dst_v4" update-ref refs/heads/$branch $commit_id

	echo "$entry $commit_id" >> "$mapping_entries_v3_v4"

	echo $first_commit_id
}

# Add an issue short name in the issues table
# $1 : destination v4 smit project (must be a bare git repo)
# $2 : issue id (decimal)
# $3 : id of the first entry (hash)
create_issue_ref() {
	dst_v4="$1"
	issue_id=$2
	first_entry_id=$3
	branch_name=issues_short_names
	filename=issues.txt

	existing=$(git -C "$dst_v4" show-ref --heads -s $branch_name)
	tmp=$(mktemp)
	if [ "$existing" = "" ]; then
		:
	else
		# recall the existing tree
		treeid=$(git -C "$dst_v4" cat-file -p $existing | awk '$1 == "tree" { print $2; }')
		object_id=$(git -C "$dst_v4" ls-tree $treeid $filename | awk '{ print $3; }')
		git -C "$dst_v4" cat-file -p $object_id > "$tmp"
	fi

	git -C "$dst_v4" read-tree --empty
	echo "$first_entry_id $issue_id" >> "$tmp"

	id=$(git -C "$dst_v4" hash-object -w "$tmp")
	git -C "$dst_v4" update-index --add --cacheinfo 100644 $id "$filename"
	tree_id=$(git -C "$dst_v4" write-tree)

	msg="create_issue_ref $issue_id"
	if [ "$existing" = "" ]; then
		commit_id=$(git -C "$dst_v4" commit-tree $tree_id -m "$msg")
	else
		commit_id=$(git -C "$dst_v4" commit-tree $tree_id -p $existing -m "$msg")
	fi
	# update the branch
	git -C "$dst_v4" update-ref refs/heads/$branch_name $commit_id
} 

# $1 : source v3 smit project
# $2 : destination v4 smit entries (must be a bare git repo)
# $3 : file for the mapping of entries v3 <=> v4
convert_v3_to_v4_issues() {
	# convert issues
	# in v4, each issue is a branch named issues/<first-entry-hash>
	# A file associates the hash of the first entry with a short name (decimal growing number)
	local src_v3="$1"
	local dst_v4="$2"
	local mapping_entries_v3_v4="$3"

	for i in $(ls "$src_v3"/.smip/refs/issues/* 2>/dev/null); do
		debug "issues $i..."
		id=$(cat "$i")
		issue_id=$(basename "$i")
		first_commit_id=""

		history=$(get_v3_history "$src_v3" "$id")

		for entry in $history; do
			printf "." # progress bar
			# for each item of history
			author=$(cat_file_v3 "$src_v3" $entry | grep ^+author | head -1 | sed -e "s/.* //")
			ctime=$(cat_file_v3 "$src_v3" $entry | grep ^+ctime | head -1 | sed -e "s/.* //")
			amended=$(cat_file_v3 "$src_v3" $entry | grep ^+amend | head -1 | sed -e "s/.* //")

			if [ "$amended" != "" ]; then
				# retrieve the v4 commit associated with the amended entry
				amended=$(grep "^$amended " "$mapping_entries_v3_v4" | sed -e "s/.* //")
			fi

			# environment variables used by git commit-tree
			export GIT_AUTHOR_NAME="$author"
			export GIT_AUTHOR_EMAIL="<>"
			export GIT_AUTHOR_DATE="$ctime"

			x_first_commit_id=$(
			cat_file_v3 "$src_v3" "$entry" |
			awk -v entry=$entry -v amended="$amended" 'BEGIN { boundary=""; multiline_prefix=""; print "convert_v3_to_v4_issues\n"; }
			boundary=="" && $2=="<" { boundary=$3;
									  if ($1=="+message") {
										  multiline_prefix="msg";
									  } else {
										  multiline_prefix="property " $1;
										  print multiline_prefix, "<";
									  }
									  next; }
	 		boundary=="" && $1 !~ /^+/ { print "property", $0; next; }
	 		boundary=="" && $1 == "+amend" { print "amend", amended; next; }
			boundary!="" && $1==boundary { boundary=""; next; }
			boundary!="" { print multiline_prefix, $0; }
			END { print "\nsmit-v3-id:", entry; }
			' | create_commit_issues "$src_v3" "$dst_v4" "$first_commit_id" $entry "$mapping_entries_v3_v4"
			)
			if [ -z "$first_commit_id" ]; then
				first_commit_id=$x_first_commit_id
				# add the new issue in the association file
				create_issue_ref "$dst_v4" $issue_id $first_commit_id
			fi
		done
	done
	echo # terminate the progress bar
}
# convert smit tags to git notes
# $1 : source v3 smit project
# $2 : destination v4 smit entries (must be a bare git repo)
# $3 : file for the mapping of entries v3 <=> v4
convert_v3_to_v4_tags() {
	local src_v3="$1"
	local dst_v4="$2"
	local mapping_entries_v3_v4="$3"

	# recall the history...
	id=$(cat "$src_v3/.smip/refs/tags" 2>/dev/null)
	history=$(get_v3_history "$src_v3" "$id")

	# replay and commit
	for tag in $history; do
		debug tag=$tag
		author=$(cat_file_v3 "$src_v3" $tag | grep "^+author" | sed -e "s/^+author *//")
		ctime=$(cat_file_v3 "$src_v3" $tag | grep "^+ctime" | sed -e "s/.* //")
		tag_name=$(cat_file_v3 "$src_v3" $tag | grep "^+tag" | awk '{print $2;}')
		tagged_entry=$(cat_file_v3 "$src_v3" $tag | grep "^+tag" | awk '{print $3;}')
		# retrieve the v4 commit associated with this entry
		v4_entry=$(grep "^$tagged_entry " "$mapping_entries_v3_v4" | sed -e "s/.* //")

		# format is: 
		# tag <tag-id>
		# tag <tag-id>
		# ...

		# if the tag is already present, remove it.
		# else: add it
		# (and preserve other tags)

		git -C "$dst_v4" notes show $v4_entry 2>/dev/null | awk -v tag_name="$tag_name" '
		BEGIN { was_present = 0; }
		$1 == "tag" && $2 == tag_name { was_present = 1; next; }
		{ print $0; }
		END { if (!was_present) print "tag", tag_name; }
		' | git -C "$dst_v4" notes add --force --file=- $v4_entry 2>/dev/null

	done
}


# main
info $0 $*
convert_v3_to_v4_master "$src_v3" "$dst_v4"

MAPPING_ENTRIES_V3_V4=$(mktemp)

convert_v3_to_v4_issues "$src_v3" "$dst_v4/.git" "$MAPPING_ENTRIES_V3_V4"
convert_v3_to_v4_tags "$src_v3" "$dst_v4/.git" "$MAPPING_ENTRIES_V3_V4"

# restore dst_v4 staging index
git -C "$dst_v4" reset master

rm "$MAPPING_ENTRIES_V3_V4"


