#!/bin/sh

usage() {
	echo "Usage: $0 <project-v2> <project-v3>"
	echo
	echo "SMPARSER must point to the smparser tool."
	exit 1
}

error() {
	echo "error: $*"
}

die() {
	error "$*"
	exit 1
}

if [ ! -x "$SMPARSER" ]; then
	die "SMPARSER does not point to an executable."
fi
SMPARSER=$(realpath "$SMPARSER")

src_v3="$1"
dst_v4="$2"

if [ "$src_v3" = "" -o "$dst_v4" = "" ]; then
	usage
fi

if [ ! -d "$src_v3/.smip" ]; then
	die "source directory '$src_v3' is not a smit project version 2."
fi

if [ -e "$dst_v4" ]; then
	die "destination directory '$dst_v4' must not exist."
fi

mkdir "$dst_v4" || exit 1


# main
# init new repo
git init "$dst_v4"

cat_file_v3() {
	project_dir="$1"
	object_id=$2
	prefix=$(echo $object_id | sed -e "s/\(..\).*/\\1"/)
	suffix=$(echo $object_id | sed -e "s/^..//")
	cat "$project_dir/.smip/objects/$prefix/$suffix"
}

get_v3_history() {
	local src_v3="$1"
	parent="$2"
	if [ "$parent" = "" ]; then return; fi

	history=""
	while [ "$parent" != null ]; do
		history="$parent $history"
		parent=$(cat_file_v3 "$src_v3" $parent | grep ^+parent | sed -e "s/^+parent *//")
	done
	echo $history
}

convert_v3_to_v4_master_file() {
	src_v3="$1"
	dst_v4="$2"
	filename="$3"
	new_location="$4" # within $dst_v4

	# recall the history...
	id=$(cat $src_v3/.smip/refs/$filename)
	history=$(get_v3_history "$src_v3" "$id")

	# replay and commit
	for i in $history; do
		author=$(cat_file_v3 "$src_v3" $i | grep +author | sed -e "s/.* //")
		ctime=$(cat_file_v3 "$src_v3" $i | grep +ctime | sed -e "s/.* //")
		cat_file_v3 "$src_v3" $i |
			grep -v ^+ > "$dst_v4/$new_location"
		(cd "$dst_v4"; git add $new_location; git commit -m "convert_v3_to_v4_master" --author "$author <>" --date=$ctime)
	done
}

convert_v3_to_v4_master() {
	# create files in branch 'master'
	local src_v3="$1"
	local dst_v4="$2"

	author=convert_v3_to_v4_master
	conf_v4=config.d

	# Project configuration and templates
	mkdir -p "$dst_v4/$conf_v4/templates"

	# project configuration
	convert_v3_to_v4_master_file "$src_v3" "$dst_v4" project "$conf_v4/config"

	# views
	id=$(cat $src_v3/.smip/refs/views)
	cat_file_v3 "$src_v3" $id > "$dst_v4/$conf_v4/views"
	(cd "$dst_v4"; git add $conf_v4/views)

	# templates
	if [ -d "$src_v3/.smip/templates" ]; then
		(cd "$src_v3/.smip/templates"; find . ! -type d ! -name ".*" ) |
		while [ 1 = 1 ]; do
			read file
			if [ "$file" = "" ]; then
				break
			fi
			subdir=$(dirname "$file")
			mkdir -p "$dst_v4/$conf_v4/templates/$subdir"
			cp "$src_v3/.smip/templates/$file" "$dst_v4/$conf_v4/templates/$file"
			(cd "$dst_v4"; git add "$conf_v4/templates/$file")
		done
	fi
	# trigger
	if [ -f "$src_v3/.smip/refs/trigger" ]; then
		cp "$src_v3/.smip/refs/trigger" "$dst_v4/$conf_v4/trigger"
		(cd "$dst_v4"; git add "$conf_v4/trigger")
	fi

	# other pages, files,...
	# a limitation here: pages of a nested projects will be included
	# in the parent project.
	(cd "$src_v3"; find . ! -type d ! -path "*/.smip/*" ! -name ".*" ) |
	while [ 1 = 1 ]; do
		read file
		if [ "$file" = "" ]; then
			break
		fi
		subdir=$(dirname "$file")
		mkdir -p "$dst_v4/data/$subdir"
		cp "$src_v3/$file" "$dst_v4/data/$subdir/."
		(cd "$dst_v4"; git add "data/$file")
	done
	(cd "$dst_v4"; git commit -m "convert_v3_to_v4_master" --author "$author <>")

}

# $1 : src smit-v3 repository
# $2 : dest smit-v4 repo (must be a bare repo)
# $3 : branch name where to commit
# $4 : the original entry of the v3 repo
# $5 : the file for mapping v3 and v4 entries identifiers
create_commit() {

	echo create_commit $*

	local src_v3=$(realpath "$1")
	local dst_v4="$2"
    local branch=$3 # make an orphan branch if not existing
	local entry=$4
	local mapping_entries_v3_v4="$5"
    # stdin: commit message

	cd "$dst_v4" # must be a bare git repository

    git read-tree --empty

    shift 3

	# attached files
	# use smparser in order to manage spaces in file names
	# manage at most 10 attached files in a single entry
	files=""
	for i in $(seq 1 10); do
		f=$(cat_file_v3 "$src_v3" "$entry" | "$SMPARSER" - +file $i)
		if [ "$f" = "" ]; then
			# no more file
			break
		fi

		hash=$(echo $f | sed -e "s;/.*;;")
		base_name=$(echo $f | sed -e "s;.*/;;")
		id=$(cat_file_v3 "$src_v3" $hash | git hash-object -w --stdin)
        git update-index --add --cacheinfo 100644 $id "$base_name"
	done

    tree_id=$(git write-tree)

    parent_id=$(cat refs/heads/$branch 2>/dev/null)
	echo parent_id=$parent_id
    if [ "$parent_id" = "" ]; then
        # this is the first commit in the orphan branch
        # read from stdin
        commit_id=$(git commit-tree $tree_id)
    else
        # read from stdin
        commit_id=$(git commit-tree $tree_id -p $parent_id)
    fi

    # update the branch
    git update-ref refs/heads/$branch $commit_id

	echo "$entry $commit_id" >> "$mapping_entries_v3_v4"

	cd - > /dev/null # back to previous working directory
}

convert_v3_to_v4_issues() {
	# convert issues
	# in v4, each issue is a branch named issues/<id>
	local src_v3="$1"
	local dst_v4="$2"
	local mapping_entries_v3_v4="$3"

	for i in "$src_v3"/.smip/refs/issues/*; do
		id=$(cat "$i")
		branch="issues/$(basename $i)"

		history=$(get_v3_history "$src_v3" "$id")

		for entry in $history; do
			# for each item of history
			author=$(cat_file_v3 "$src_v3" $entry | grep +author | head -1 | sed -e "s/.* //")
			ctime=$(cat_file_v3 "$src_v3" $entry | grep +ctime | head -1 | sed -e "s/.* //")
			# environment variables used by git commit-tree
			export GIT_AUTHOR_NAME="$author"
			export GIT_AUTHOR_EMAIL="<>"
			export GIT_AUTHOR_DATE="$ctime"

			cat_file_v3 "$src_v3" "$entry" |
			awk -v entry=$entry 'BEGIN { boundary=""; multiline_prefix=""; print "convert_v3_to_v4_issues\n"; }
			boundary=="" && $2=="<" { boundary=$3;
		                              if ($1=="+message") {
			                              multiline_prefix="msg";
			                          } else {
			                              multiline_prefix="property " $1;
			                          }
									  print multiline_prefix, "<";
			                          next; }
	 		boundary=="" && $1 !~ /^+/ { print "property", $0; next; }
	 		boundary=="" && $1 == "+amend" { print "amend", $2; next; }
			boundary!="" && $1==boundary { boundary=""; next; }
			boundary!="" { print multiline_prefix, $0; }
			END { print "\nsmit-v3-id:", entry; }
			' | create_commit "$src_v3" "$dst_v4/.git" $branch $entry "$mapping_entries_v3_v4"
		done
	done
}
# convert smit tags to git notes
convert_v3_to_v4_tags() {
	local src_v3="$1"
	local dst_v4="$2"
	local mapping_entries_v3_v4="$3"

	# recall the history...
	id=$(cat $src_v3/.smip/refs/tags)
	history=$(get_v3_history "$src_v3" "$id")

	# replay and commit
	for tag in $history; do
		echo tag=$tag
		author=$(cat_file_v3 "$src_v3" $tag | grep "^+author" | sed -e "s/^+author *//")
		ctime=$(cat_file_v3 "$src_v3" $tag | grep "^+ctime" | sed -e "s/.* //")
		tag_name=$(cat_file_v3 "$src_v3" $tag | grep "^+tag" | awk '{print $2;}')
		tagged_entry=$(cat_file_v3 "$src_v3" $tag | grep "^+tag" | awk '{print $3;}')
		# retrieve the v4 commit associated with this entry
		v4_entry=$(grep "^$tagged_entry " "$mapping_entries_v3_v4" | sed -e "s/.* //")

		# format is: 
		# tag <tag-id>
		# tag <tag-id>
		# ...

		# if the tag is already present, remove it.
		# else: add it
		# (and preserve other tags)

		(cd "$dst_v4"; git notes show $v4_entry) | awk -v tag_name="$tag_name" '
		BEGIN { was_present = 0; }
		$1 == "tag" && $2 == tag_name { was_present = 1; next; }
		{ print $0; }
		END { if (!was_present) print "tag", tag_name; }
		' | (cd "$dst_v4"; git notes add --force --file=- $v4_entry)

	done
}

MAPPING_ENTRIES_V3_V4=$(mktemp)
convert_v3_to_v4_master "$src_v3" "$dst_v4"
convert_v3_to_v4_issues "$src_v3" "$dst_v4" "$MAPPING_ENTRIES_V3_V4"
convert_v3_to_v4_tags "$src_v3" "$dst_v4" "$MAPPING_ENTRIES_V3_V4"

# restore dst_v4 staging index
(cd "$dst_v4" && git reset master)

rm "$MAPPING_ENTRIES_V3_V4"


