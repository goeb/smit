#!/bin/sh

usage() {
	echo "Usage: $0 <project-v2> <project-v3>"
	exit 1
}

error() {
	echo "error: $*"
}

die() {
	error "$*"
	exit 1
}

src_v3="$1"
dst_v4="$2"

if [ "$src_v3" = "" -o "$dst_v4" = "" ]; then
	usage
fi

if [ ! -d "$src_v3/.smip" ]; then
	die "source directory '$src_v3' is not a smit project version 2."
fi

if [ -e "$dst_v4" ]; then
	die "destination directory '$dst_v4' must not exist."
fi

mkdir "$dst_v4" || exit 1


# main
# init new repo
git init "$dst_v4"

cat_file_v3() {
	project_dir="$1"
	object_id=$2
	prefix=$(echo $object_id | sed -e "s/\(..\).*/\\1"/)
	suffix=$(echo $object_id | sed -e "s/^..//")
	cat "$project_dir/.smip/objects/$prefix/$suffix"
}

get_v3_history() {
	local src_v3="$1"
	parent="$2"
	history=""
	while [ "$parent" != null ]; do
		history="$parent $history"
		parent=$(cat_file_v3 "$src_v3" $parent | grep ^+parent | sed -e "s/^+parent *//")
	done
	echo $history
}

convert_v3_to_v4_master_file() {
	src_v3="$1"
	dst_v4="$2"
	filename="$3"
	new_location="$4" # within $dst_v4

	# recall the history...
	id=$(cat $src_v3/.smip/refs/$filename)
	history=$(get_v3_history "$src_v3" "$id")

	# replay and commit
	for i in $history; do
		author=$(cat_file_v3 "$src_v3" $i | grep +author | sed -e "s/.* //")
		ctime=$(cat_file_v3 "$src_v3" $i | grep +ctime | sed -e "s/.* //")
		cat_file_v3 "$src_v3" $i |
			grep -v ^+ > "$dst_v4/$new_location"
		(cd "$dst_v4"; git add $new_location; git commit -m "convert_v3_to_v4_master" --author "$author <>" --date=$ctime)
	done
}

convert_v3_to_v4_master() {
	# create files in branch 'master'
	local src_v3="$1"
	local dst_v4="$2"

	author=convert_v3_to_v4_master
	conf_v4=config.d

	# Project configuration and templates
	mkdir -p "$dst_v4/$conf_v4/templates"

	# project configuration
	convert_v3_to_v4_master_file "$src_v3" "$dst_v4" project "$conf_v4/config"

	# views
	id=$(cat $src_v3/.smip/refs/views)
	cat_file_v3 "$src_v3" $id > "$dst_v4/$conf_v4/views"
	(cd "$dst_v4"; git add $conf_v4/views)

	# templates
	if [ -d "$src_v3/.smip/templates" ]; then
		(cd "$src_v3/.smip/templates"; find . ! -type d ! -name ".*" ) |
		while [ 1 = 1 ]; do
			read file
			if [ "$file" = "" ]; then
				break
			fi
			subdir=$(dirname "$file")
			mkdir -p "$dst_v4/$conf_v4/templates/$subdir"
			cp "$src_v3/.smip/templates/$file" "$dst_v4/$conf_v4/templates/$file"
			(cd "$dst_v4"; git add "$conf_v4/templates/$file")
		done
	fi
	# trigger
	if [ -f "$src_v3/.smip/refs/trigger" ]; then
		cp "$src_v3/.smip/refs/trigger" "$dst_v4/$conf_v4/trigger"
		(cd "$dst_v4"; git add "$conf_v4/trigger")
	fi

	# other pages, files,...
	(cd "$src_v3"; find . ! -type d ! -path "*/.smip/*" ! -name ".*" ) |
	while [ 1 = 1 ]; do
		read file
		if [ "$file" = "" ]; then
			break
		fi
		subdir=$(dirname "$file")
		mkdir -p "$dst_v4/data/$subdir"
		cp "$src_v3/$file" "$dst_v4/data/$subdir/."
		(cd "$dst_v4"; git add "data/$file")
	done
	(cd "$dst_v4"; git commit -m "convert_v3_to_v4_master" --author "$author <>")

}

# $1 : src smit-v3 repository
# $2 : dest smit-v4 repo (must be a bare repo)
# $3 : branch name where to commit
# other arguments : list of files
#                   format: <sha1>/<basename> ...
create_commit() {

	echo create_commit $*

	local src_v3=$(realpath "$1")
	local dst_v4="$2"
    local branch=$3 # make an orphan branch if not existing
    # stdin: commit message

	cd "$dst_v4" # must be a bare git repository

    git read-tree --empty

    shift 3
	for f in $*; do
        # add file in index
		hash=$(echo $f | sed -e "s;/.*;;")
		base_name=$(echo $f | sed -e "s;.*/;;")
		id=$(cat_file_v3 "$src_v3" $hash | git hash-object -w --stdin)
        git update-index --add --cacheinfo 100644 $id "$base_name"
	done

    tree_id=$(git write-tree)

    parent_id=$(cat refs/heads/$branch 2>/dev/null)
	echo parent_id=$parent_id
    if [ "$parent_id" = "" ]; then
        # this is the first commit in the orphan branch
        # read from stdin
        commit_id=$(git commit-tree $tree_id)
    else
        # read from stdin
        commit_id=$(git commit-tree $tree_id -p $parent_id)
    fi

    # update the branch
    git update-ref refs/heads/$branch $commit_id

	cd - > /dev/null # back to previous working directory
}

convert_v3_to_v4_issues() {
	# convert issues
	# in v4, each issue is a branch named issues/<id>
	local src_v3="$1"
	local dst_v4="$2"

	for i in "$src_v3"/.smip/refs/issues/*; do
		id=$(cat "$i")
		branch="issues/$(basename $i)"

		history=$(get_v3_history "$src_v3" "$id")

		for entry in $history; do
			# for each item of history
			author=$(cat_file_v3 "$src_v3" $entry | grep +author | head -1 | sed -e "s/.* //")
			ctime=$(cat_file_v3 "$src_v3" $entry | grep +ctime | head -1 | sed -e "s/.* //")
			export GIT_AUTHOR_NAME="$author"
			export GIT_AUTHOR_DATE="$ctime"

			# attached files
			files=$(cat_file_v3 "$src_v3" "$entry" | grep "^+file" | head -1)
			files=$(echo $files | sed -e "s/^+file *//") # remove key

			cat_file_v3 "$src_v3" "$entry" |
			awk -v entry=$entry 'BEGIN { boundary=""; multiline_prefix=""; print "convert_v3_to_v4_issues\n"; }
			boundary=="" && $2=="<" { boundary=$3;
		                              if ($1=="+message") {
			                              multiline_prefix="msg";
			                          } else {
			                              multiline_prefix="property " $1;
			                          }
									  print multiline_prefix, "<";
			                          next; }
	 		boundary=="" && $1 !~ /^+/ { print "property", $0; next; }
	 		boundary=="" && $1 == "+amend" { print "amend", $2; next; }
			boundary!="" && $1==boundary { boundary=""; next; }
			boundary!="" { print multiline_prefix, $0; }
			END { print "\nsmit-v3-id:", entry; }
			' | create_commit "$src_v3" "$dst_v4/.git" $branch $files
		done
	done
}
convert_v3_to_v4_tags() {
	echo TODO convert_v3_to_v4_tags
}
convert_v3_to_v4_master "$src_v3" "$dst_v4"
convert_v3_to_v4_issues "$src_v3" "$dst_v4"
convert_v3_to_v4_tags "$src_v3" "$dst_v4"



